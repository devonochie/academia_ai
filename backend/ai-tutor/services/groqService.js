// services/groqService.js
const Groq = require("groq-sdk");
const InstructionSet = require("../instruction/InstructionSet");

class GroqService {
  constructor() {
    if (!process.env.GROQ_API_KEY) {
      throw new Error("GROQ_API_KEY is not configured");
    }
    
    this.groq = new Groq({
      apiKey: process.env.GROQ_API_KEY,
      timeout: 30000 // 30 seconds timeout
    });
    this.instructions = InstructionSet;
  }
  
  async generateContent(phase, userInput, options = {}) {
    try {
      const instruction = this.instructions.getInstruction(phase);
      if (!instruction) throw new Error("Invalid phase specified");

      // Sanitize input
      const sanitizedInput = {
        topic: typeof userInput.topic === 'string' ? userInput.topic.substring(0, 100) : '',
        difficulty: ['Novice', 'Intermediate', 'Expert'].includes(userInput.difficulty) 
          ? userInput.difficulty 
          : 'Intermediate'
      };

      const prompt = {
        role: "user",
        content: `Generate a complete curriculum in strict JSON format following this exact schema:
${instruction.content}

Topic: ${sanitizedInput.topic}
Difficulty: ${sanitizedInput.difficulty}
Additional Options: ${JSON.stringify(options)}

STRICT REQUIREMENTS:
1. Output MUST be valid JSON that matches the schema exactly
2. Do not include any markdown, code fences, or explanatory text
3. Escape all special characters in strings
4. Ensure all required fields are present
5. No trailing commas in arrays or objects
6. Each lesson must have at least 3 components
7. Modules must have at least 5 lessons

IMPORTANT: If you cannot generate valid JSON, respond with an empty object {}`
      };

      const messages = [instruction, prompt];

      const response = await this.groq.chat.completions.create({
        messages,
        model: options.model || "llama3-70b-8192",
        temperature: options.temperature || 0.7,
        max_tokens: options.max_tokens || 4000,
        response_format: { type: "json_object" }
      });

      const content = response.choices[0]?.message?.content;
      if (!content) throw new Error("No content generated");

      let parsed;
      try {
        parsed = JSON.parse(content);
      } catch (parseError) {
        console.error("Failed to parse JSON:", content);
        throw new Error("Invalid JSON generated by AI");
      }

      if (Object.keys(parsed).length === 0) {
        throw new Error("AI failed to generate valid content");
      }

      if (!this.validateStructure(phase, parsed)) {
        console.error("Validation failed for:", parsed);
        throw new Error("Generated content doesn't match required structure");
      }

      return parsed;
    } catch (error) {
      console.error("Groq generation error:", error);
      throw new Error(`Content generation failed: ${error.message}`);
    }
  }

  validateStructure(phase, content) {
    const validators = {
      curriculumGenerator: (data) => (
        data.metadata && 
        typeof data.metadata.topic === 'string' &&
        ['Novice', 'Intermediate', 'Expert'].includes(data.metadata.difficulty) &&
        Array.isArray(data.modules) &&
        data.modules.every(m => 
          Array.isArray(m.lessons) &&
          m.lessons.every(l => 
            Array.isArray(l.components) && 
            l.components.length >= 3
          )
        )
      ),
       lessonGenerator: (data) => (
      data.lesson_meta &&
      data.core_content?.theoretical_foundation?.key_concepts?.length >= 3 &&
      data.assessment?.knowledge_check?.questions?.length >= 5
      ),
      recommendationEngine: (data) => (
        data.analysis?.skill_gaps?.length > 0 &&
        data.recommendations?.short_term?.length > 0 &&
        typeof data.compatibility_score === 'number'
      ),
      assessmentGenerator: (data) => (
        data.diagnostic?.pre_test?.questions?.length > 0 &&
        data.formative?.feedback_mechanisms?.length > 0
      ),
      progressTracker: (data) => (
        data.progress?.modules?.length > 0 &&
        data.progress.modules.every(m => 
          m.lessons && 
          m.lessons.every(l => l.status && l.completion_percentage >= 0 && l.completion_percentage <= 100)
        )
      ),
      interactiveTutor: (data) => (
        typeof data.response === 'string' &&
        typeof data.metadata === 'object' &&
        typeof data.metadata.current_topic === 'string' &&
        Array.isArray(data.metadata.next_steps) &&
        typeof data.metadata.progress_update === 'object' &&
        Array.isArray(data.metadata.progress_update.concepts_covered) &&
        typeof data.metadata.progress_update.mastery_level !== 'undefined' &&
        // knowledge_check is optional, but if present, must have question and expected_answer
        (
          !data.metadata.knowledge_check ||
          (
            typeof data.metadata.knowledge_check === 'object' &&
            typeof data.metadata.knowledge_check.question === 'string' &&
            typeof data.metadata.knowledge_check.expected_answer === 'string'
          )
        )
      )
    };

    return validators[phase] ? validators[phase](content) : false;
  }
}

module.exports = new GroqService();